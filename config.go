package genstruct

import (
	"fmt"
	"reflect"
	"regexp"
	"strings"
	"time"

	"github.com/dave/jennifer/jen"
)

// Config holds the configuration for code generation of static structs and arrays.
type Config struct {
	// PackageName defines the Target package name (optional)
	// If not provided, the package name will be the same as the given struct.
	PackageName      string
	TypeName         string   // The name of the struct type to generate
	ConstantIdent    string   // Prefix for constants (e.g., "Post" for "PostMyPostID")
	VarPrefix        string   // Prefix for variables (e.g., "Post" for "PostMyPost")
	OutputFile       string   // Output file name
	IdentifierFields []string // Fields to try using for naming, in priority order (optional)
	// Custom function to generate variable names (optional)
	// If provided, this takes precedence over IdentifierFields
	CustomVarNameFn func(structValue reflect.Value) string
}

// Generator is responsible for generating code for static struct arrays
type Generator struct {
	Config Config
	Data   any // The array of structs to generate code for
	File   *jen.File
}

// NewGenerator creates a new generator instance
func NewGenerator(config Config, data any) *Generator {
	// Set default identifier fields if none provided
	if config.IdentifierFields == nil {
		config.IdentifierFields = []string{"ID", "Name", "Slug", "Title", "Key", "Code"}
	}

	return &Generator{
		Config: config,
		Data:   data,
		File:   jen.NewFile(config.PackageName),
	}
}

// Generate performs the code generation
func (g *Generator) Generate() error {
	g.File.PackageComment(fmt.Sprintf(
		"// Generated by genstruct. DO NOT EDIT.\n// Package %s contains auto-generated %s data",
		g.Config.PackageName,
		g.Config.TypeName,
	))

	// Validate that we have an array or slice
	dataValue := reflect.ValueOf(g.Data)
	if dataValue.Kind() != reflect.Slice &&
		dataValue.Kind() != reflect.Array {
		return NonSliceOrArrayError{dataValue.Kind()}
	}

	// Make sure we have at least one element to analyze the type
	if dataValue.Len() == 0 {
		return EmptyError{}
	}

	// Get the type of the first element
	firstElem := dataValue.Index(0)
	if firstElem.Kind() != reflect.Struct {
		return InvalidTypeError{firstElem.Kind()}
	}

	// Generate constants for IDs if there's an ID field
	g.generateConstants(dataValue)

	// Generate variables for each struct
	g.generateVariables(dataValue)

	// Generate a slice with all structs
	g.generateSlice(dataValue)

	// Save the generated code to file
	return g.File.Save(g.Config.OutputFile)
}

// getTypeStatement converts a reflect.Type to a jen.Statement
func (g *Generator) getTypeStatement(t reflect.Type) *jen.Statement {
	switch t.Kind() {
	case reflect.Bool:
		return jen.Bool()
	case reflect.Int,
		reflect.Int8,
		reflect.Int16,
		reflect.Int32,
		reflect.Int64:
		return jen.Id(t.String())
	case reflect.Uint,
		reflect.Uint8,
		reflect.Uint16,
		reflect.Uint32,
		reflect.Uint64,
		reflect.Uintptr:
		return jen.Id(t.String())
	case reflect.Float32, reflect.Float64:
		return jen.Id(t.String())
	case reflect.Complex64, reflect.Complex128:
		return jen.Id(t.String())
	case reflect.Array, reflect.Slice:
		return jen.Index().Add(g.getTypeStatement(t.Elem()))
	case reflect.Map:
		return jen.Map(
			g.getTypeStatement(t.Key()),
		).Add(g.getTypeStatement(t.Elem()))
	case reflect.String:
		return jen.String()
	case reflect.Struct:
		// Handle special types like time.Time
		if t.String() == "time.Time" {
			return jen.Qual("time", "Time")
		}
		return jen.Id(t.Name())
	case reflect.Pointer:
		return jen.Op("*").Add(g.getTypeStatement(t.Elem()))
	case reflect.Interface:
		if t.NumMethod() == 0 {
			return jen.Interface() // empty interface
		}
		// Complex interfaces would need more handling
		return jen.Interface()
	default:
		return jen.Id(t.String())
	}
}

// generateConstants creates ID constants for each struct if an ID field exists
func (g *Generator) generateConstants(dataValue reflect.Value) {
	// Check if the struct has an ID field
	firstElem := dataValue.Index(0)
	hasIDField := false
	idFieldName := ""

	// Look for an "ID" field (case insensitive)
	for i := range firstElem.NumField() {
		fieldName := firstElem.Type().Field(i).Name
		if strings.ToLower(fieldName) == "id" {
			hasIDField = true
			idFieldName = fieldName
			break
		}
	}

	if !hasIDField {
		return // No ID field found
	}

	// Create constants for each ID
	g.File.Const().DefsFunc(func(group *jen.Group) {
		for i := range dataValue.Len() {
			elem := dataValue.Index(i)
			idField := elem.FieldByName(idFieldName)

			// If there's an ID field that's a string, create a constant
			if idField.IsValid() &&
				idField.Kind() == reflect.String {

				idValue := idField.String()
				// If ID is empty, generate one
				if idValue == "" {
					idValue = fmt.Sprintf("%s-%d", strings.ToLower(g.Config.TypeName), i+1)
				}

				// Get a name for the constant based on the struct
				identValue := g.getStructIdentifier(elem)

				constName := g.Config.ConstantIdent + slugToIdentifier(identValue) + "ID"
				group.Id(constName).Op("=").Lit(idValue)
			}
		}
	})
}

// getStructIdentifier returns a string to identify this struct instance
func (g *Generator) getStructIdentifier(structValue reflect.Value) string {
	// If a custom name function is provided, use it
	if g.Config.CustomVarNameFn != nil {
		return g.Config.CustomVarNameFn(structValue)
	}

	// Try all configured identifier fields
	for _, fieldName := range g.Config.IdentifierFields {
		field := structValue.FieldByName(fieldName)
		if field.IsValid() && field.Kind() == reflect.String && field.String() != "" {
			return field.String()
		}
	}

	// Fallback 1: Look for any string field
	for i := range structValue.NumField() {
		field := structValue.Field(i)
		if field.Kind() == reflect.String && field.String() != "" {
			return field.String()
		}
	}

	// Fallback 2: Generate a name based on the type
	return fmt.Sprintf("%s-%d", g.Config.TypeName, time.Now().UnixNano())
}

// generateVariables creates variables for each struct
func (g *Generator) generateVariables(dataValue reflect.Value) {
	// Generate a variable for each struct
	for i := range dataValue.Len() {
		elem := dataValue.Index(i)

		// Determine the variable name using the identifier function
		identValue := g.getStructIdentifier(elem)
		varName := g.Config.VarPrefix + slugToIdentifier(identValue)

		// Create the variable with its value
		g.File.Var().Id(varName).Op("=").Id(g.Config.TypeName).ValuesFunc(func(group *jen.Group) {
			g.generateStructValues(group, elem)
		})
	}
}

// generateStructValues adds values for a struct to a Dict
func (g *Generator) generateStructValues(group *jen.Group, structValue reflect.Value) {
	structType := structValue.Type()

	// Create a Dict for each field in the struct
	dict := jen.Dict{}

	for i := range structValue.NumField() {
		field := structValue.Field(i)
		fieldType := structType.Field(i)

		// Skip unexported fields
		if !fieldType.IsExported() {
			continue
		}

		// Add the field to the dict
		dict[jen.Id(fieldType.Name)] = g.getValueStatement(field)
	}

	// Add all fields to the group
	group.Add(dict)
}

// getValueStatement generates code for a value based on its type
func (g *Generator) getValueStatement(value reflect.Value) *jen.Statement {
	switch value.Kind() {
	case reflect.Bool:
		return jen.Lit(value.Bool())
	case reflect.Int,
		reflect.Int8,
		reflect.Int16,
		reflect.Int32,
		reflect.Int64:
		return jen.Lit(value.Int())
	case reflect.Uint,
		reflect.Uint8,
		reflect.Uint16,
		reflect.Uint32,
		reflect.Uint64:
		return jen.Lit(value.Uint())
	case reflect.Float32, reflect.Float64:
		return jen.Lit(value.Float())
	case reflect.Complex64, reflect.Complex128:
		return jen.Lit(value.Complex())
	case reflect.Array:
		// Handle arrays properly with their type and dimensions
		elemType := g.getTypeStatement(value.Type().Elem())
		dimensions := value.Len()

		// Create array type with dimensions
		arrayType := jen.Index(jen.Lit(dimensions)).Add(elemType)

		// Create values inside the array
		return arrayType.ValuesFunc(func(group *jen.Group) {
			for i := range value.Len() {
				group.Add(g.getValueStatement(value.Index(i)))
			}
		})
	case reflect.Slice:
		// Create a slice with proper syntax
		return jen.Index().Add(
			g.getTypeStatement(value.Type().Elem()),
		).ValuesFunc(func(group *jen.Group) {
			for i := range value.Len() {
				group.Add(g.getValueStatement(value.Index(i)))
			}
		})
	case reflect.Map:
		return g.getMapStatement(value)
	case reflect.String:
		return jen.Lit(value.String())
	case reflect.Struct:
		// Special case for time.Time
		if value.Type().String() == "time.Time" {
			t := value.Interface().(time.Time)
			return jen.Qual("time", "Date").Call(
				jen.Lit(t.Year()),
				jen.Qual("time", t.Month().String()),
				jen.Lit(t.Day()),
				jen.Lit(t.Hour()),
				jen.Lit(t.Minute()),
				jen.Lit(t.Second()),
				jen.Lit(t.Nanosecond()),
				jen.Qual("time", "UTC"),
			)
		}
		// For other structs, create a new values block with the struct fields
		return jen.Id(
			value.Type().Name(),
		).ValuesFunc(func(group *jen.Group) {
			g.generateStructValues(group, value)
		})
	case reflect.Pointer:
		if value.IsNil() {
			return jen.Nil()
		}
		return jen.Op("&").Add(g.getValueStatement(value.Elem()))
	case reflect.Interface:
		if value.IsNil() {
			return jen.Nil()
		}
		return g.getValueStatement(value.Elem())
	default:
		// For complex cases, fallback to string representation
		return jen.Lit(fmt.Sprintf("%v", value.Interface()))
	}
}

// getMapStatement generates code for a map
func (g *Generator) getMapStatement(mapValue reflect.Value) *jen.Statement {
	// Return empty map if there are no entries
	if mapValue.Len() == 0 {
		return jen.Map(
			g.getTypeStatement(mapValue.Type().Key()),
		).Add(
			g.getTypeStatement(mapValue.Type().Elem()),
		).Values()
	}

	// Use ValuesFunc for populated maps
	return jen.Map(
		g.getTypeStatement(mapValue.Type().Key()),
	).Add(
		g.getTypeStatement(mapValue.Type().Elem()),
	).ValuesFunc(func(group *jen.Group) {
		// Create a Dict for the map entries
		dict := jen.Dict{}
		var key reflect.Value

		// Add all key-value pairs to the Dict
		for _, key = range mapValue.MapKeys() {
			var stmt = g.getValueStatement(mapValue.MapIndex(key))
			dict[g.getValueStatement(key)] = stmt
		}

		// Add dict to group
		group.Add(dict)
	})
}

// generateSlice creates a slice containing all struct instances
func (g *Generator) generateSlice(dataValue reflect.Value) {
	// Determine the slice name - handle both regular and irregular plurals
	var sliceName string
	if g.Config.TypeName[len(g.Config.TypeName)-1] == 's' ||
		g.Config.TypeName[len(g.Config.TypeName)-1] == 'x' ||
		g.Config.TypeName[len(g.Config.TypeName)-1] == 'z' ||
		strings.HasSuffix(g.Config.TypeName, "sh") ||
		strings.HasSuffix(g.Config.TypeName, "ch") {
		sliceName = fmt.Sprintf(
			"All%ses",
			g.Config.TypeName,
		)
	} else if g.Config.TypeName[len(g.Config.TypeName)-1] == 'y' {
		sliceName = fmt.Sprintf(
			"All%sies",
			g.Config.TypeName[:len(g.Config.TypeName)-1],
		)
	} else {
		sliceName = fmt.Sprintf("All%ss", g.Config.TypeName)
	}

	g.File.Var().Id(
		sliceName,
	).Op(
		"=",
	).Index().Id(
		g.Config.TypeName,
	).ValuesFunc(func(group *jen.Group) {
		for i := range dataValue.Len() {
			elem := dataValue.Index(i)

			// Get the variable name using the same method as in generateVariables
			identValue := g.getStructIdentifier(elem)
			varName := g.Config.VarPrefix + slugToIdentifier(identValue)

			group.Id(varName)
		}
	})
}

// slugToIdentifier converts a string to a valid Go identifier
func slugToIdentifier(s string) string {
	// Replace non-alphanumeric characters with spaces
	reg := regexp.MustCompile("[^a-zA-Z0-9]+")
	processed := reg.ReplaceAllString(s, " ")

	// Title case each word and remove spaces
	words := strings.Fields(processed)
	for i, word := range words {
		if len(word) > 0 {
			words[i] = strings.ToUpper(word[0:1]) + strings.ToLower(word[1:])
		}
	}

	return strings.Join(words, "")
}
