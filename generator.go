package genstruct

import (
	"fmt"
	"reflect"
	"time"

	"github.com/dave/jennifer/jen"
)

// Generator is responsible for generating code for static struct arrays
type Generator struct {
	Config Config
	Data   any // The array of structs to generate code for
	File   *jen.File
}

// NewGenerator creates a new generator instance
func NewGenerator(config Config, data any) *Generator {
	// Set default identifier fields if none provided
	if config.IdentifierFields == nil {
		config.IdentifierFields = []string{"ID", "Name", "Slug", "Title", "Key", "Code"}
	}

	return &Generator{
		Config: config,
		Data:   data,
		File:   jen.NewFile(config.PackageName),
	}
}

// Generate performs the code generation
func (g *Generator) Generate() error {
	g.File.PackageComment(fmt.Sprintf(
		"// Code generated by genstruct. DO NOT EDIT.\n// Package %s contains auto-generated %s data",
		g.Config.PackageName,
		g.Config.TypeName,
	))

	// Validate that we have an array or slice
	dataValue := reflect.ValueOf(g.Data)
	if dataValue.Kind() != reflect.Slice &&
		dataValue.Kind() != reflect.Array {
		return NonSliceOrArrayError{dataValue.Kind()}
	}

	// Make sure we have at least one element to analyze the type
	if dataValue.Len() == 0 {
		return EmptyError{}
	}

	// Get the type of the first element
	firstElem := dataValue.Index(0)
	if firstElem.Kind() != reflect.Struct {
		return InvalidTypeError{firstElem.Kind()}
	}

	// Generate constants for IDs if there's an ID field
	g.generateConstants(dataValue)

	// Generate variables for each struct
	g.generateVariables(dataValue)

	// Generate a slice with all structs
	g.generateSlice(dataValue)

	// Save the generated code to file
	return g.File.Save(g.Config.OutputFile)
}

// getStructIdentifier returns a string to identify this struct instance
func (g *Generator) getStructIdentifier(structValue reflect.Value) string {
	// If a custom name function is provided, use it
	if g.Config.CustomVarNameFn != nil {
		return g.Config.CustomVarNameFn(structValue)
	}

	// Try all configured identifier fields
	for _, fieldName := range g.Config.IdentifierFields {
		field := structValue.FieldByName(fieldName)
		if field.IsValid() && field.Kind() == reflect.String && field.String() != "" {
			return field.String()
		}
	}

	// Fallback 1: Look for any string field
	for i := range structValue.NumField() {
		field := structValue.Field(i)
		if field.Kind() == reflect.String && field.String() != "" {
			return field.String()
		}
	}

	// Fallback 2: Generate a name based on the type
	return fmt.Sprintf("%s-%d", g.Config.TypeName, time.Now().UnixNano())
}
